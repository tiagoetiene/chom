#!/usr/bin/env node

_ 				= require("underscore");
MongoClient	= require("mongodb").MongoClient;
ObjectID 		= require('mongodb').ObjectID
Twit 			= require("twit");
Readable 		= require('stream').Readable;
emitter			= require('events').EventEmitter;
moment		= require('moment');

args			= require("./fetch/args");
out				= require("./libs/out");
utils			= require('./libs/utils');

var inputCertificate = program.certificate;
var inputKeywords = program.keywords;
var inputGroup = program.group;
var inputLang = ( program.lang ) ? program.lang : "en";
var inputStream = ( program.stream ) ? true : false;
var inputSearch = ( program.search ) ? program.search : false;
var inputUntilDate = ( typeof inputSearch != "boolean" ) ? inputSearch : "";
var inputDatabase = program.database;
var inputCloseOnExit = program.close;

var totalNumberOfTweets = { tweets : 0 };

//
// Establishing connection with twitter
// 
if( inputSearch || inputStream ) {
	console.assert( inputCertificate != undefined );
	var T;
	if( inputGroup == undefined ) {
		T = new Twit( inputCertificate[ 0 ] );
	} else {
		T = new Twit( inputCertificate[ inputGroup ] );
	}	
}

//
// Pre-processing keywords
//
if( inputKeywords ) {
	var group = ( inputCertificate ) ? inputCertificate.length : 1;

	//
	// Removing all keywords that are empty strigns
	//
	inputKeywords = _.filter( inputKeywords, function( keyword, idx ) {
		return _.isEmpty( keyword ) == false;
	} );

	//
	// Separating the input keywords in groups, according to the number
	// of twitter certificates available
	//
	inputKeywords = _.filter( inputKeywords, function( keyword, idx ) {
		return idx % group == 0;
	});

	//
	// Lower casering and adding "@" if needed
	//
	_.each( inputKeywords, function( keyword, idx ) {
		inputKeywords[ idx ] = ((keyword.charAt(0) == "@") ? "" : "@") + keyword.toLowerCase();
	});
}

process.stdout.setMaxListeners( 0 );

function printTweet( datum ) {

	if( inputKeywords ) {
		var message = datum.text.toLowerCase();

		_.each( inputKeywords, function( keyword ) {
			if( message.indexOf( keyword ) != -1 ) {
				datum.keyword = keyword;
				datum.created_at = new Date( datum.created_at );
				process.stdout.write( JSON.stringify( datum ) + "\n" );
				totalNumberOfTweets.tweets++;
			}
		} );
	} else {
		process.stdout.write( JSON.stringify( datum ) + "\n" );
		totalNumberOfTweets.tweets++;
	}
	
}


if( inputStream ) {

	//
	// Starting stream of tweets
	//
	var stream = T.stream( "statuses/filter", { track: inputKeywords, language: inputLang });
	stream.on( "tweet", printTweet );

} else if( inputSearch ) {

	//
	//  Search for all tweets 
	//
	var q = "";
	_.each( inputKeywords, function( keyword, idx ) {
		q += keyword;
		q += ( idx < ( inputKeywords.length - 1) ) ?  " OR " : "";
	});
	
	var first = true;
	var maxid = "";
	var stop = false;
	var running = false;
	var handle = setInterval( function() {
		if( stop ) {
			clearInterval( handle );
		} else {
			// In case nothing is running, let's do something
			if( running == false ) {

				// Ok, running has started
				running = true;

				// Building query string
				var options = { q : q, count : 100};
				if( _.isEmpty( maxid ) == false ) {
					options.max_id =  maxid;	
				}
				if( _.isEmpty( inputUntilDate ) == false && first == true ) {
					var date = moment( new Date( inputUntilDate ) );
					options.until = date.format( "YYYY-MM-DD");
					first = false;
				}

				T.get( 'search/tweets', options, function( err, data, response ) {
					if( err ) {
						console.log( "* Error found while searching tweets: ", err );
						throw err;
					}

					if( data != undefined ) {
						var tweets = data.statuses;
						_.each( tweets, function( tweet ) { if( tweet.id ) printTweet( tweet ); });

						if( data.search_metadata ) {
							var next = data.search_metadata.next_results;
							if( next ) {
								var matches = next.match( /\?\max\_id=(.+?)\&/ );
								if( matches.length == 2 ) {
									// Retrieving next page
									maxid = matches[ 1 ];
								}
							}
						}
					}
					running = false;
				});
			}
		}
	}, 2100 );
} else if( inputDatabase ) {

	//
	// Reads data from database, instead of the internet
	//
	MongoClient.connect( inputDatabase.mongo_url, function(err, db) {
	
		if(err)  {
			console.log('* Error found while connecting to the database:', err);
			throw err;
		}

		var collection = db.collection( inputDatabase.collection );

		//
		// latestID helps with streaming: let's get tweets 
		// with ID greater than the latest
		//
		var lastestID = new ObjectID( 0 );

		//
		// Tracking whether streaming is running or not
		//
		var isRunning = false;
		setInterval( function() {

			//
			// We are polling the database constantly.
			// Thus, we will start a new stream, only if we reached 
			// the end of the database, in other words, if there are
			// no streams running
			//
			if( isRunning == false ) {

				//
				// Streaming just started, let's make it true :)
				//
				isRunning = true;

				//
				// The beginning of our streaming process is lastestID
				//
				var stream = collection.find( {  _id : { $gt :  lastestID } } ).sort( [ [ "_id", "asc" ] ] ).stream();

				//
				// When a tweet arrive, let's print it (to the console)
				//
				stream.on( "data", function( tweet ) {
					if( err ) {
						console.log('* Error found while searching collection:', err);
						throw err;
					}
					lastestID = tweet._id;
					printTweet( tweet );
				} );

				//
				// Case we reach the end, then we are no longer runniing
				//
				stream.on( "close", function() {
					isRunning = false;
					if( inputCloseOnExit ) {
						process.stdout.write( JSON.stringify( {} ) + "\n" );
						
						db.close();
						process.exit();
					}
				});

				//
				// Case we reach an error, let's print it
				//
				stream.on( "error", function( err ) {
					process.stderr.write( JSON.stringify( err ) );
					isRunning = false;
				});
			}
		}, 2000 );
	} );
}

utils.printToFile( "/tmp/chom.fetch.txt", totalNumberOfTweets );